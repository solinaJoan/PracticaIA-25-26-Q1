\section{Representació de l'estat}
\label{sec:state}

\vspace{0.5cm}

\subsection{La importància de la representació}

La representació de l'estat és, sens dubte, una de les decisions de disseny més crítiques en qualsevol problema de cerca. Una bona representació no només facilita la implementació dels operadors i la funció heurística, sinó que també determina l'eficiència computacional de tota la solució. 

Quan vam començar a pensar en com representar un estat del problema, vam considerar diverses alternatives. Podríem haver representat una solució com una matriu d'assignacions, com una llista de tuples (petició, camió, viatge), o com una estructura més complexa que inclogués informació redundant per accelerar consultes. Després d'analitzar els pros i contres de cada opció, vam optar per una representació basada en llistes de viatges per camió, que expliquem en detall a continuació.

\vspace{0.5cm}

\subsection{Anàlisi previ de l'espai de cerca}

Abans de decidir com representar un estat, és fonamental comprendre la magnitud de l'espai amb el qual treballem. Aquesta anàlisi ens ajudarà a justificar les decisions que prendrem.

\vspace{0.5cm}

\subsubsection{Càlcul teòric de la mida de l'espai}

Considerem un escenari amb $n$ camions, $p$ peticions a servir, i la restricció que cada camió pot fer màxim $v$ viatges. Per cada petició, hem de decidir:

\begin{enumerate}
    \item Si la servim o no
    \item En cas afirmatiu, quin camió l'atendrà
    \item A quin viatge d'aquest camió s'assignarà
    \item En quin ordre dins del viatge
\end{enumerate}

Només considerant les assignacions de peticions a camions (ignorant l'ordre i l'agrupació en viatges), tenim $(n+1)^p$ possibilitats: cada petició pot ser assignada a qualsevol dels $n$ camions o quedar sense servir. Per al nostre escenari base amb 10 camions i aproximadament 100 peticions, això ja suposa $11^{100} \approx 10^{104}$ possibilitats.

\vspace{0.5cm}

\subsection{Estructura de dades escollida}

Després d'analitzar diverses alternatives, hem optat per una representació basada en llistes de viatges organitzades per camió. Aquesta decisió es fonamenta en diversos raonaments que exposem a continuació.

\vspace{0.5cm}

\subsubsection{Components de l'estat}

L'estat del nostre problema es compon de diverses parts que hem de distingir clarament entre dades estàtiques (compartides per tots els estats) i dades dinàmiques (específiques de cada estat).

\paragraph{Dades estàtiques:}

Les dades estàtiques són aquelles que no varien durant la cerca. Aquestes es declaren com a variables de classe (static en Java) i es comparteixen entre totes les instàncies d'estats:

\begin{lstlisting}[caption={Dades estàtiques de l'estat}, label={lst:static-data}]
public class PracticaBoard {
    // Informacio del problema (compartida per tots els estats)
    private static Gasolineras gasolineres;
    private static CentrosDistribucion centres;
    private static Map<Integer, Peticio> peticions;
    
    // Constants del problema
    private static final int KM_MAX = 640;
    private static final int VIATGES_MAX = 5;
    private static final double COST_KM = 2.0;
    private static final double PREU_BASE = 1000.0;
    
    // ...
}
\end{lstlisting}

Aquesta separació és crucial per l'eficiència espacial. Si tinguéssim 10.000 estats en memòria simultàniament (cosa que pot passar durant la cerca), duplicar aquesta informació en cada estat seria extremadament ineficient. Amb l'aproximació estàtica, aquestes dades s'emmagatzemen una sola vegada.

\paragraph{Dades dinàmiques:}

Les dades dinàmiques representen la solució específica d'aquest estat i varien d'un estat a un altre:

\begin{lstlisting}[caption={Dades dinàmiques de l'estat}, label={lst:dynamic-data}]
public class PracticaBoard {
    // ...
    
    // Assignacions especifiques d'aquest estat
    private List<List<Viatge>> assignacions;  // viatges per camio
    private Set<Integer> peticionsServides;
    
    // Metriques pre-calculades (per eficiencia)
    private double beneficiTotal;
    private int[] kmPerCamio;
    private int[] viatgesPerCamio;
}
\end{lstlisting}

La llista \texttt{assignacions} és el nucli de la representació. És una llista de llistes: per a cada camió (índex de la llista exterior) tenim una llista dels seus viatges. Aquesta estructura bidimensional ens permet accedir directament als viatges d'un camió específic en temps constant.

El conjunt \texttt{peticionsServides} ens permet verificar ràpidament si una petició ja està assignada, operació que fem freqüentment. Utilitzar un conjunt (HashSet) en lloc d'una llista redueix la complexitat d'aquesta verificació de $O(p)$ a $O(1)$.

Les mètriques pre-calculades són una optimització important. En lloc de recalcular el benefici total cada vegada que el necessitem, el calculem una vegada després de cada modificació i el guardem. Això és especialment útil per a Hill Climbing, que necessita comparar el valor heurístic de múltiples estats successors.


\vspace{0.5cm}

\subsection{Complexitat espacial i temporal}

Analitzem formalment la complexitat de la nostra representació per validar que és eficient.

\vspace{0.5cm}

\subsubsection{Complexitat espacial}

Per un estat amb $n$ camions i $p_s$ peticions servides:

\begin{itemize}
    \item \textbf{Assignacions}: Cada camió té com a màxim 5 viatges amb 2 peticions cada un $\rightarrow O(n \cdot 10) = O(n)$
    \item \textbf{Peticions servides}: Un conjunt de mida $p_s$ $\rightarrow O(p_s)$
    \item \textbf{Mètriques}: Arrays de mida $n$ $\rightarrow O(n)$
    \item \textbf{Total}: $O(n + p_s)$
\end{itemize}

En la pràctica, amb $n = 10$ i $p_s \approx 90$, cada estat ocupa aproximadament uns pocs kilobytes de memòria, cosa que permet tenir milers d'estats en memòria simultàniament sense problemes.


\vspace{0.5cm}

\subsection{Alternatives considerades i descartades}

Abans d'arribar a la representació final, vam considerar i descartar diverses alternatives.

\vspace{0.5cm}

\subsubsection{Representació com a llista plana de tuples}

Una alternativa seria representar l'estat com una llista de tuples (petició, camió, viatge, posició). Aquesta representació és molt flexible però té desavantatges:

\begin{itemize}
    \item Dificulta l'accés a tots els viatges d'un camió
    \item Requereix ordenar o filtrar la llista per moltes operacions
    \item No encapsula la lògica de viatges
    \item Més propensa a errors (tuples amb 4 components)
\end{itemize}

\vspace{0.5cm}

\subsubsection{Representació amb grafs}

Podríem modelar les assignacions com un graf on els nodes són gasolineres i els arcs representen l'ordre de visita. Aquesta representació, tot i ser elegant matemàticament, és massa complexa per les nostres necessitats:

\begin{itemize}
    \item Sobredimensionada per a viatges amb màxim 2 gasolineres
    \item Dificulta les modificacions locals
    \item Requereix llibreries addicionals
    \item Més costosa en memòria
\end{itemize}

\vspace{0.5cm}

\subsubsection{Representació amb informació redundant}

Una altra opció seria mantenir múltiples estructures de dades (per exemple, tant una llista de viatges com un mapa de peticions a viatges). Això acceleraria algunes consultes però:

\begin{itemize}
    \item Augmenta significativament l'ús de memòria
    \item Requereix mantenir la coherència entre estructures
    \item El guany en velocitat no compensa la complexitat afegida
\end{itemize}
